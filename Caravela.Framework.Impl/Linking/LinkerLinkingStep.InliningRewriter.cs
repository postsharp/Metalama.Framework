// Copyright (c) SharpCrafters s.r.o. All rights reserved.
// This project is not open source. Please see the LICENSE.md file in the repository root for details.

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Caravela.Framework.Impl.Linking
{
    internal partial class LinkerLinkingStep
    {
        /// <summary>
        /// Produces inlined method body. This rewriter is used recursively when inlining call to the previous (inner) transformation.
        /// </summary>
        private class InliningRewriter : CSharpSyntaxRewriter
        {
            private static readonly string _inlineableBlockAnnotationId = "AspectLinkerInlineableBlock";

            private readonly LinkerAnalysisRegistry _analysisRegistry;
            private readonly SemanticModel _semanticModel;
            private readonly IMethodSymbol _contextSymbol;
            private readonly string? _returnVariableName;
            private readonly int? _returnLabelId;

            public InliningRewriter( LinkerAnalysisRegistry referenceRegistry, SemanticModel semanticModel, IMethodSymbol contextSymbol, string? returnVariableName = null, int? returnLabelId = null )
            {
                this._analysisRegistry = referenceRegistry;
                this._semanticModel = semanticModel;
                this._contextSymbol = contextSymbol;
                this._returnVariableName = returnVariableName;
                this._returnLabelId = returnLabelId;
            }

            public override SyntaxNode? VisitExpressionStatement( ExpressionStatementSyntax node )
            {
                var updatedExpression = this.Visit( node.Expression );

                if ( updatedExpression == null )
                {
                    return null;
                }

                if ( updatedExpression.Kind() == SyntaxKind.Block )
                {
                    return updatedExpression.WithAdditionalAnnotations( new SyntaxAnnotation( _inlineableBlockAnnotationId ) );
                }

                return node.Update( this.VisitList( node.AttributeLists ), (ExpressionSyntax) updatedExpression, this.VisitToken( node.SemicolonToken ) );
            }

            // This is currently not needed, because this form is not generated by the template compiler.

            /*
            public override SyntaxNode? VisitLocalDeclarationStatement( LocalDeclarationStatementSyntax node )
            {
                // Variable declaration - if there is inlineable call, we need to break this statement into multiple declarations.

                // First go through all declared variables and look if there is a linker annotated invocation.
                bool anyBlockifiedInitializer = false;
                Dictionary<VariableDeclaratorSyntax, SyntaxNode?> rewrittenDeclarators = new Dictionary<VariableDeclaratorSyntax, SyntaxNode?>();
                foreach (var declarator in node.Declaration.Variables)
                {
                    var initializerExpr = declarator.Initializer?.Value;
                    var annotation = initializerExpr?.GetLinkerAnnotation();                    
                    if ( annotation != null )
                    {
                        // This is a linker annotated invocation: var x = ..., >> y = Foo(...) <<, z = ...;
                        // If the target is not inlineable, rewrite the call to the final destination.
                        // If the target is inlineable, break the variable declaration into following block:
                        // var x = ...; 
                        // <return_type> y;
                        // <inlined_body>
                        // var z = ...;
                        var calleeSymbol = this._semanticModel.GetSymbolInfo( initializerExpr.AssertNotNull() ).Symbol.AssertNotNull();

                        // If the body is inlineable, inline it.
                        var resolvedSymbol = (IMethodSymbol) this._analysisRegistry.ResolveSymbolReference( this._contextSymbol, calleeSymbol, annotation );
                        if ( this._analysisRegistry.IsBodyInlineable( resolvedSymbol ) )
                        {
                            // Inline the method body.
                            return this.GetInlinedMethodBody( resolvedSymbol, null );
                        }
                        else
                        {
                            return initializerExpr.Update( this.ReplaceCallTarget( node.Expression, resolvedSymbol ), node.ArgumentList );
                        }

                        if ( updatedInitializerExpression != declarator.Initializer )
                        {
                            if ( updatedInitializerExpression is BlockSyntax )
                            {
                                anyBlockifiedInitializer = true;
                            }

                            rewrittenDeclarators[declarator] = updatedInitializerExpression;
                        }
                    }
                }

                if ( anyBlockifiedInitializer )
                {
                    List<StatementSyntax> variableStatements = new List<StatementSyntax>();

                    foreach ( var declarator in node.Declaration.Variables )
                    {
                        if ( rewrittenDeclarators.TryGetValue( declarator, out SyntaxNode updatedInitializerExpression ) )
                        {
                            if ( updatedInitializerExpression is BlockSyntax blockSyntax )
                            {
                                variableStatements.Add( node.WithDeclaration( node.Declaration.WithVariables( SeparatedList( new[] { declarator.WithInitializer( null ) } ) ) ) );
                                variableStatements.Add( blockSyntax );
                            }
                            else
                            {
                                variableStatements.Add(
                                    node.WithDeclaration(
                                        node.Declaration.WithVariables(
                                            SeparatedList(
                                                new[]
                                                {
                                                    declarator.WithInitializer(
                                                        declarator.Initializer?.WithValue((ExpressionSyntax)updatedInitializerExpression ) )
                                                } ) ) ) );
                            }                            
                        }
                        else
                        {
                            variableStatements.Add( node.WithDeclaration( node.Declaration.WithVariables( SeparatedList( new[] { declarator } ) ) ) );
                        }
                    }

                    return Block( variableStatements ).WithAdditionalAnnotations( new SyntaxAnnotation( _inlineableBlockAnnotationId ) );
                }
                else if ( rewrittenDeclarators.Count > 0 )
                {
                    return node.WithDeclaration(
                        node.Declaration.WithVariables(
                            SeparatedList(
                                node.Declaration.Variables
                                .Select( v =>
                                    rewrittenDeclarators.ContainsKey( v )
                                    ? v.WithInitializer( EqualsValueClause( (ExpressionSyntax) rewrittenDeclarators[v] ) )
                                    : v ) ) ) );
                }
                else
                {
                    return node;
                }
            }*/

            public override SyntaxNode? VisitBlock( BlockSyntax node )
            {
                var newSyntax = base.VisitBlock( node );

                if ( newSyntax is BlockSyntax newBlock )
                {
                    var statements = new List<StatementSyntax>();

                    if ( FlattenBlock( newBlock, statements ) )
                    {
                        return newBlock.WithStatements( List( statements ) );
                    }
                    else
                    {
                        return newBlock;
                    }
                }
                else
                {
                    return newSyntax;
                }
            }

            // TODO: This should move to a separate rewriter and unite with what template compiler currently does (or should do).

            /// <summary>
            /// Recursively adds statements from flattenable blocks.
            /// </summary>
            /// <param name="block">Block.</param>
            /// <param name="statementList"></param>
            /// <returns></returns>
            private static bool FlattenBlock(BlockSyntax block, List<StatementSyntax> statementList )
            {
                // TODO: recursion may not be needed but is more efficient.
                var anyFlattened = false;

                foreach ( var statement in block.Statements )
                {
                    if ( statement.GetAnnotations( _inlineableBlockAnnotationId ).Any() )
                    {
                        anyFlattened = true;
                        FlattenBlock( (BlockSyntax) statement, statementList );
                    }
                    else
                    {
                        statementList.Add( statement );
                    }
                }

                return anyFlattened;
            }

            public override SyntaxNode? VisitInvocationExpression( InvocationExpressionSyntax node )
            {
                // TODO: out, ref parameters.
                var annotation = node.GetLinkerAnnotation();

                if ( annotation == null )
                {
                    // Normal invocation.
                    return base.VisitInvocationExpression( node );
                }

                // This is an invocation of a void method that can be possibly inlined.     
                var calleeSymbol = this._semanticModel.GetSymbolInfo( node ).Symbol.AssertNotNull();

                // If the body is inlineable, inline it.
                var resolvedSymbol = (IMethodSymbol) this._analysisRegistry.ResolveSymbolReference( this._contextSymbol, calleeSymbol, annotation.AssertNotNull() );
                if ( this._analysisRegistry.IsBodyInlineable( resolvedSymbol ) )
                {
                    // TODO: Inlineability also depends on parameters passed. 
                    //       Method is inlineable if only if:
                    //           * Call's argument expressions match parameter names of the caller.
                    //           * Parameter names of the caller match parameter names of the callee.
                    //           * Caller and callee signatures are equal.
                    //       This is satisfied for all proceed().

                    // Inline the method body.
                    return this.GetInlinedMethodBody( resolvedSymbol, null );
                }
                else
                {
                    return node.Update( this.ReplaceCallTarget( (IMethodSymbol) calleeSymbol, node.Expression, resolvedSymbol ), node.ArgumentList );
                }
            }

            public override SyntaxNode? VisitAssignmentExpression( AssignmentExpressionSyntax node )
            {
                var annotation = node.Right.GetLinkerAnnotation();

                if ( annotation == null )
                {
                    return base.VisitAssignmentExpression( node );
                }

                var invocation = (InvocationExpressionSyntax) node.Right;

                // This is an invocation of a non-void method that can be possibly inlined.     
                var calleeSymbol = this._semanticModel.GetSymbolInfo( invocation ).Symbol.AssertNotNull();

                // We are on an assignment of a method return value to a variable.      
                var resolvedSymbol = (IMethodSymbol) this._analysisRegistry.ResolveSymbolReference( this._contextSymbol, calleeSymbol, annotation.AssertNotNull() );
                if ( this._analysisRegistry.IsBodyInlineable( resolvedSymbol ) )
                {
                    // TODO: Inlineability also depends on parameters passed. 
                    //       Method is inlineable if only if:
                    //           * Call's argument expressions match parameter names of the caller.
                    //           * Parameter names of the caller match parameter names of the callee.
                    //           * Caller and callee signatures are equal.
                    //       This is satisfied for all proceed().

                    // Inline the method body.
                    return this.GetInlinedMethodBody( resolvedSymbol, this.GetAssignmentVariableName( node.Left ) );
                }
                else
                {
                    // Replace with invocation of the correct override.
                    return node.Update( node.Left, node.OperatorToken, invocation.Update( this.ReplaceCallTarget( (IMethodSymbol) calleeSymbol, invocation.Expression, resolvedSymbol ), invocation.ArgumentList ) );
                }
            }

            private BlockSyntax? GetInlinedMethodBody( IMethodSymbol calledMethodSymbol, string? returnVariableName )
            {
                var labelId = this.GetNextReturnLabelId();

                // Create the top-most inlining rewriter for the called method.
                var innerRewriter = new InliningRewriter( this._analysisRegistry, this._semanticModel, calledMethodSymbol, returnVariableName, labelId );
                var declaration = (MethodDeclarationSyntax) calledMethodSymbol.DeclaringSyntaxReferences.Single().GetSyntax();

                // Run the inlined method's body through the rewriter.
                var rewrittenBlock = (BlockSyntax) innerRewriter.VisitBlock( declaration.Body.AssertNotNull() ).AssertNotNull();

                // TODO: Replace with unified annotation for prettification rewriter.
                rewrittenBlock = rewrittenBlock.WithAdditionalAnnotations( new SyntaxAnnotation( _inlineableBlockAnnotationId ) );

                if ( this._analysisRegistry.HasSimpleReturnControlFlow( calledMethodSymbol ) || (!calledMethodSymbol.ReturnsVoid && returnVariableName == null ) )
                {
                    // This method had simple control flow, we can keep the block as-is
                    return rewrittenBlock;
                }
                else
                {
                    // The method does not have simple control flow - we should expect goto's and thus create a label.
                    // TODO: The label should be on the next statement, not on empty statement (but that needs to be done after block flattening).
                    return
                        Block(
                            rewrittenBlock.AssertNotNull(),
                            LabeledStatement( this.GetReturnLabelName( labelId ), EmptyStatement() ) )
                        .WithAdditionalAnnotations( new SyntaxAnnotation( _inlineableBlockAnnotationId ) );
                }
            }

            /// <summary>
            /// Replaces call target for non-inlineable methods.
            /// </summary>
            /// <param name="originalSymbol">Original symbol targeted by the call.</param>
            /// <param name="expression">Call expression.</param>
            /// <param name="methodSymbol"></param>
            /// <returns></returns>
            private ExpressionSyntax ReplaceCallTarget( IMethodSymbol originalSymbol, ExpressionSyntax expression, IMethodSymbol methodSymbol )
            {
                var memberAccess = (MemberAccessExpressionSyntax) expression;

                if ( SymbolEqualityComparer.Default.Equals( originalSymbol, methodSymbol ) )
                {
                    return memberAccess.Update( memberAccess.Expression, memberAccess.OperatorToken, IdentifierName( LinkingRewriter.GetOriginalBodyMethodName( methodSymbol.Name ) ) );
                }
                else
                {
                    return memberAccess.Update( memberAccess.Expression, memberAccess.OperatorToken, IdentifierName( methodSymbol.Name ) );
                }
            }

            public override SyntaxNode? VisitReturnStatement( ReturnStatementSyntax node )
            {
                // TODO: ref return etc.

                var linkerAnnotation = node.Expression?.GetLinkerAnnotation();
                if ( linkerAnnotation != null )
                {
                    // This is an annotated invocation. By visiting the expression, we will either get a invocation or a block if the invocation target is inlineable.

                    var updatedExpression = this.Visit( node.Expression );

                    if ( updatedExpression == null )
                    {
                        return null;
                    }

                    if ( updatedExpression.Kind() == SyntaxKind.Block )
                    {
                        return updatedExpression.WithAdditionalAnnotations( new SyntaxAnnotation( _inlineableBlockAnnotationId ) );
                    }

                    return node.WithExpression( (ExpressionSyntax) updatedExpression );
                }

                if ( this._returnLabelId != null )
                {
                    // We are in the inner inlining case and we have a return label we need to jump to instead of returning.
                    if ( node.Expression != null )
                    {
                        if ( this._returnVariableName != null )
                        {
                            if ( this._analysisRegistry.HasSimpleReturnControlFlow( this._contextSymbol ) )
                            {
                                return
                                    ExpressionStatement(
                                        AssignmentExpression(
                                            SyntaxKind.SimpleAssignmentExpression,
                                            IdentifierName( this._returnVariableName ),
                                            node.Expression ) );
                            }
                            else
                            {
                                return
                                    Block(
                                        ExpressionStatement(
                                            AssignmentExpression(
                                                SyntaxKind.SimpleAssignmentExpression,
                                                IdentifierName( this._returnVariableName.AssertNotNull() ),
                                                node.Expression ) ),
                                        GotoStatement(
                                            SyntaxKind.GotoStatement,
                                            IdentifierName( this.GetReturnLabelName( this._returnLabelId.Value ) ) ) )
                                    .WithAdditionalAnnotations( new SyntaxAnnotation( _inlineableBlockAnnotationId ) );
                            }
                        }
                        else
                        {
                            return node;
                        }
                    }
                    else
                    {
                        if ( this._returnVariableName == null )
                        {
                            if ( this._analysisRegistry.HasSimpleReturnControlFlow( this._contextSymbol ) )
                            {
                                return null;
                            }
                            else
                            {
                                return
                                    GotoStatement(
                                        SyntaxKind.GotoStatement,
                                        IdentifierName( this.GetReturnLabelName( this._returnLabelId.Value ) ) );
                            }
                        }
                        else
                        {
                            // This happens when a template assigns result into a variable but is then applied on a void method.
                            return
                                GotoStatement(
                                    SyntaxKind.GotoStatement,
                                    IdentifierName( this.GetReturnLabelName( this._returnLabelId.Value ) ) );
                        }
                    }
                }
                else
                {
                    if ( this._returnVariableName == null )
                    {
                        return node;
                    }
                    else
                    {
                        throw new AssertionFailedException();
                    }
                }
            }

            private string GetAssignmentVariableName( ExpressionSyntax left )
            {
                switch ( left.Kind() )
                {
                    case SyntaxKind.IdentifierName:
                        return ((IdentifierNameSyntax) left).Identifier.Text;

                    default:
                        throw new NotImplementedException( $"TODO {left.Kind()}" );
                }
            }

            private int GetNextReturnLabelId() => (this._returnLabelId ?? 0) + 1;

            // TODO: Create more contextual return label names.
            private string GetReturnLabelName( int returnLabelId ) => $"__aspect_return_{returnLabelId}";
        }
    }
}
