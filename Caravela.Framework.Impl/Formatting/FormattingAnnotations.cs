// Copyright (c) SharpCrafters s.r.o. All rights reserved.
// This project is not open source. Please see the LICENSE.md file in the repository root for details.

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace Caravela.Framework.Impl.Formatting
{
    internal static class FormattingAnnotations
    {
        /// <summary>
        /// Annotation that means that the syntax has been generated by Caravela. This is used to selectively format the code,
        /// and can be used in the future for syntax highlighting.
        /// </summary>
        public static readonly SyntaxAnnotation GeneratedCode = new( "Caravela_Generated" );

        /// <summary>
        /// Annotation that means that the syntax stems from source code. This can be added to a child node of a node annotated
        /// with <see cref="GeneratedCode"/>.
        /// </summary>
        public static readonly SyntaxAnnotation SourceCode = new( "Caravela_SourceCode" );

        [return: NotNullIfNotNull( "node" )]
        private static T? AddAnnotationInsideBlock<T>( this T? node, SyntaxAnnotation annotation, bool addToBrackets = false )
            where T : SyntaxNode
        {
            switch ( node )
            {
                case BlockSyntax block:
                    var annotatedBlock = (T) (object) block.WithStatements(
                        SyntaxFactory.List( block.Statements.Select( s => s.AddAnnotationInsideBlock( annotation, true ) ) ) );

                    if ( addToBrackets )
                    {
                        annotatedBlock = annotatedBlock.WithAdditionalAnnotations( annotation );
                    }

                    return annotatedBlock;

                default:
                    return node?.WithAdditionalAnnotations( annotation );
            }
        }

        [return: NotNullIfNotNull( "node" )]
        public static T? AddGeneratedCodeAnnotation<T>( this T? node )
            where T : SyntaxNode
            => node?.AddAnnotationInsideBlock( GeneratedCode );

        [return: NotNullIfNotNull( "node" )]
        public static T? AddSourceCodeAnnotation<T>( this T? node )
            where T : SyntaxNode
            => node?.AddAnnotationInsideBlock( SourceCode );

        [return: NotNullIfNotNull( "node" )]
        public static T? WithFormattingAnnotationsFrom<T>( this T? node, SyntaxNode source )
            where T : SyntaxNode
        {
            if ( node == null )
            {
                return null;
            }
            else if ( source.HasAnnotation( SourceCode ) )
            {
                return node.AddSourceCodeAnnotation();
            }
            else if ( source.HasAnnotation( GeneratedCode ) )
            {
                return node.AddGeneratedCodeAnnotation();
            }
            else
            {
                return node;
            }
        }
    }
}