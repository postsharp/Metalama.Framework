<Project Sdk="Microsoft.NET.Sdk">

    <Import Project="..\Build\RoslynVersion\Latest.imports"/>

    <PropertyGroup>
        <TargetFramework>netstandard2.0</TargetFramework>
        <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
        <MetalamaCompilerDisablePackCustomization>True</MetalamaCompilerDisablePackCustomization>
        <UseMetalamaCompiler>Private</UseMetalamaCompiler>
        <AssemblyName>Metalama.Framework.Engine.$(ThisRoslynVersion)</AssemblyName>
    </PropertyGroup>

    <ItemGroup>

        <!-- We have to embed the compile-time build of Metalama.Framework so we can reference it to create
             the compile-time assembly. See ReferenceAssemblyLocator                                           -->
        <EmbeddedResource Include="..\Metalama.Framework.CompileTime\bin\$(Configuration)\netstandard2.0\Metalama.Framework.dll">
            <LogicalName>Metalama.Framework.dll</LogicalName>
        </EmbeddedResource>

        <!-- We also embed the self-contained build of Metalama.Compiler.Interface.dll because at run-time, this project
            may receive the build containing forwarders (this happens in Metalama.Try). However, we need to compile against
            the self-contained version -->
        <EmbeddedResource Include="$(PkgMetalama_Compiler_Sdk)\lib\netstandard2.0\Metalama.Compiler.Interface.dll">
            <LogicalName>Metalama.Compiler.Interface.dll</LogicalName>
        </EmbeddedResource>
    </ItemGroup>

    <ItemGroup>
        <Compile Include="..\.generated\$(ThisRoslynVersion)\Metalama.Framework.Engine\*.cs"/>
    </ItemGroup>


    <ItemGroup>
        <!-- By convention, we use InternalsVisibleTo only for test projects that must have access to internals.. -->
        <InternalsVisibleTo Include="Metalama.Framework.Tests.UnitTests.Internals"/>
        <InternalsVisibleTo Include="Metalama.Framework.Tests.Integration.Internals"/>
        <InternalsVisibleTo Include="DynamicProxyGenAssembly2" Key="$(FakeItEasyKey)" LoadsWithinVisualStudio="false"/>
    </ItemGroup>

    <ItemGroup>
        <PackageReference Include="Microsoft.CodeAnalysis.CSharp.Workspaces" Version="$(ThisRoslynVersion)"/>
        <PackageReference Include="Microsoft.CodeAnalysis.Workspaces.Common" Version="$(ThisRoslynVersion)"/>
        <PackageReference Include="Metalama.Compiler.Sdk" Version="$(MetalamaCompilerVersion)">
            <GeneratePathProperty>True</GeneratePathProperty>
        </PackageReference>
        <PackageReference Include="Metalama.Backstage" Version="$(MetalamaBackstageVersion)"/>

        <PackageReference Include="Microsoft.Bcl.HashCode" Version="$(MicrosoftBclHashCodeVersion)"/>
        <PackageReference Include="K4os.Hash.xxHash" Version="$(K4osHashxxHashVersion)"/>
        <PackageReference Include="Microsoft.CSharp" Version="$(MicrosoftCSharpVersion)"/>
        <PackageReference Include="Newtonsoft.Json" Version="$(NewtonsoftJsonVersion)"/>
        <PackageReference Include="System.Runtime.Serialization.Formatters" Version="4.3.0"/>
        <ProjectReference Include="..\Metalama.Framework.Introspection\Metalama.Framework.Introspection.csproj"/>
        <ProjectReference Include="..\Metalama.Framework\Metalama.Framework.csproj"/>
        <ProjectReference Include="..\Metalama.Framework.Sdk\Metalama.Framework.Sdk.csproj"/>

        <!-- Reference PostSharp for obfuscation -->
        <PackageReference Include="PostSharp" Version="$(PostSharpPackageVersion)" PrivateAssets="all" Condition="'$(Obfuscate)' == 'True'"/>
        <ProjectReference Include="..\Build\Metalama.Obfuscator\Metalama.Obfuscator.csproj" ReferenceOutputAssembly="false" Condition="'$(Obfuscate)' == 'True'"/>

        <!-- The following references handle [Memo] -->
        <ProjectReference Include="..\Build\Metalama.SourceTransformer\Metalama.SourceTransformer.csproj" OutputItemType="Analyzer" ReferenceOutputAssembly="false"/>


    </ItemGroup>

    <!-- Obfuscation -->
    <PropertyGroup>
        <PostSharpProperties>
            ObfuscateMapFile=$(MSBuildThisFileDirectory)\bin\$(Configuration)\$(TargetFramework)\$(AssemblyName).obmap;
            ObfuscateRootPath=$(MSBuildThisFileDirectory)
        </PostSharpProperties>
        <PostSharpSearchPath>$(MSBuildThisFileDirectory)..\Build\Metalama.Obfuscator\bin\$(Configuration)\netstandard2.0</PostSharpSearchPath>
        <PostSharpDisabledMessages>PS0131</PostSharpDisabledMessages>
    </PropertyGroup>

    <Target Name="NoPackWithoutObfuscate" BeforeTargets="Pack">
        <Error Condition="'$(Configuration)' == 'Release' AND '$(Obfuscate)' != 'True'" Text="Not allowed to create Release package without obfuscation, use '-p:Obfuscate=True'."/>
    </Target>

    <!-- This is a work-around of PostSharp not preserving the public-signing flag. (#29763) -->
    <ItemGroup>
        <PackageReference Include="FakeSign" Version="0.9.2" PrivateAssets="all" GeneratePathProperty="true"/>
    </ItemGroup>

    <PropertyGroup>
        <_FixPublicSigningTouchFile>$(MSBuildThisFileDirectory)\obj\$(Configuration)\$(TargetFramework)\fakesign_touch</_FixPublicSigningTouchFile>
    </PropertyGroup>

    <Target Name="FixPublicSigning" Inputs="@(IntermediateAssembly->'%(FullPath)')" Outputs="$(_FixPublicSigningTouchFile)" AfterTargets="PostSharp">
        <Exec Command="$(PkgFakeSign)\tools\FakeSign.exe $(MSBuildProjectDirectory)\obj\$(Configuration)\$(TargetFramework)\$(AssemblyName).dll"/>
        <Touch Files="$(_FixPublicSigningTouchFile)" AlwaysCreate="True" ContinueOnError="True"/>
    </Target>

</Project>
