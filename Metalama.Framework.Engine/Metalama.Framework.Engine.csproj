<Project Sdk="Microsoft.NET.Sdk">

    <Import Project="..\Build\RoslynVersion\Latest.imports" />
    
    <PropertyGroup>
        <TargetFrameworks>netstandard2.0;net6.0</TargetFrameworks>
        <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
        <MetalamaCompilerDisablePackCustomization>True</MetalamaCompilerDisablePackCustomization>
        <UseMetalamaCompiler>Private</UseMetalamaCompiler>
        <AssemblyName>Metalama.Framework.Engine.$(ThisRoslynVersion)</AssemblyName>
        <PackageId>Metalama.Framework.Engine</PackageId>
		<!-- We need to pack Metalama.SystemTypes.dll because the test projects will not include it if they do not target .NET Standard 2.0 themselves. -->
		<PackMetalamaSystemTypes>True</PackMetalamaSystemTypes>
        <!-- Packaging -->
        <PackageDescription>The main implementation of Metalama.Framework. It should normally never be referenced in any user project.</PackageDescription>
        <PackageReadmeFile>README.md</PackageReadmeFile>
    </PropertyGroup>


    <ItemGroup>
		<ProjectReference Include="..\Metalama.Framework.CompileTime\Metalama.Framework.CompileTime.csproj" ReferenceOutputAssembly="false" />

        <!-- We have to embed the compile-time build of Metalama.Framework so we can reference it to create
             the compile-time assembly. See ReferenceAssemblyLocator                                           -->
        <EmbeddedResource Include="..\Metalama.Framework.CompileTime\bin\$(Configuration)\netstandard2.0\Metalama.Framework.dll">
            <LogicalName>Metalama.Framework.dll</LogicalName>
        </EmbeddedResource>

        <!-- We also embed the self-contained build of Metalama.Compiler.Interface.dll because at run-time, this project
            may receive the build containing forwarders (this happens in Metalama.Try). However, we need to compile against
            the self-contained version -->
        <EmbeddedResource Include="$(PkgMetalama_Compiler_Sdk)\lib\netstandard2.0\Metalama.Compiler.Interface.dll">
            <LogicalName>Metalama.Compiler.Interface.dll</LogicalName>
        </EmbeddedResource>
    </ItemGroup>

    <ItemGroup>
        <Compile Include="..\.generated\$(ThisRoslynVersion)\Metalama.Framework.Engine\*.cs" />
    </ItemGroup>

    <ItemGroup>
        <!-- By convention, we use InternalsVisibleTo only for test projects that must have access to internals.. -->
        <InternalsVisibleTo Include="Metalama.Framework.Tests.UnitTests.Internals" />
        <InternalsVisibleTo Include="Metalama.Framework.Tests.Integration.Internals" />
        <InternalsVisibleTo Include="DynamicProxyGenAssembly2" Key="$(FakeItEasyKey)" LoadsWithinVisualStudio="false" />
    </ItemGroup>

    <ItemGroup>
        <PackageReference Include="Microsoft.CodeAnalysis.CSharp.Workspaces" Version="$(ThisRoslynVersion)" />
		<PackageReference Include="Microsoft.CodeAnalysis.CSharp.Features" Version="$(ThisRoslynVersion)" />
        <PackageReference Include="Microsoft.CodeAnalysis.Workspaces.Common" Version="$(ThisRoslynVersion)" />
        <PackageReference Include="Metalama.Compiler.Sdk" Version="$(MetalamaCompilerVersion)">
            <GeneratePathProperty>True</GeneratePathProperty>
        </PackageReference>
        <PackageReference Include="Metalama.Backstage" Version="$(MetalamaBackstageVersion)" />

        <PackageReference Include="Microsoft.Bcl.HashCode" Version="$(MicrosoftBclHashCodeVersion)" />
        <PackageReference Include="K4os.Hash.xxHash" Version="$(K4osHashxxHashVersion)" />
        <PackageReference Include="Microsoft.CSharp" Version="$(MicrosoftCSharpVersion)" />
        <PackageReference Include="Newtonsoft.Json" Version="$(NewtonsoftJsonVersion)" />
        <PackageReference Include="System.Runtime.Serialization.Formatters" Version="4.3.0" />
        <ProjectReference Include="..\Metalama.Framework.DesignTime.Rpc\Metalama.Framework.DesignTime.Rpc.csproj" />
        <ProjectReference Include="..\Metalama.Framework.Introspection\Metalama.Framework.Introspection.csproj" />
        <ProjectReference Include="..\Metalama.Framework.CompileTimeContracts\Metalama.Framework.CompileTimeContracts.csproj" />
        <ProjectReference Include="..\Metalama.Framework\Metalama.Framework.csproj" />
        <ProjectReference Include="..\Metalama.Framework.Sdk\Metalama.Framework.Sdk.csproj" />

        <!-- Reference PostSharp for obfuscation -->
        <PackageReference Include="PostSharp" Version="$(PostSharpPackageVersion)" PrivateAssets="all" Condition="'$(Obfuscate)' == 'True'" />
        <ProjectReference Include="..\Build\Metalama.Obfuscator\Metalama.Obfuscator.csproj" ReferenceOutputAssembly="false" Condition="'$(Obfuscate)' == 'True'" />

        <!-- The following references handle [Memo] -->
        <ProjectReference Include="..\Build\Metalama.SourceTransformer\Metalama.SourceTransformer.csproj" OutputItemType="Analyzer" ReferenceOutputAssembly="false" />
    </ItemGroup>

    <!-- Obfuscation -->
    <PropertyGroup>
        <PostSharpProperties>
            ObfuscateMapFile=$(PackageOutputPath)\$(AssemblyName).obmap;
            ObfuscateRootPath=$(MSBuildThisFileDirectory)
        </PostSharpProperties>
        <PostSharpSearchPath>$(MSBuildThisFileDirectory)..\Build\Metalama.Obfuscator\bin\$(Configuration)\netstandard2.0</PostSharpSearchPath>
        <PostSharpDisabledMessages>PS0131</PostSharpDisabledMessages>
    </PropertyGroup>

    <Target Name="NoPackWithoutObfuscate" BeforeTargets="Pack">
        <Error Condition="'$(Configuration)' == 'Release' AND '$(Obfuscate)' != 'True'" Text="Not allowed to create Release package without obfuscation, use '-p:Obfuscate=True'." />
    </Target>

    <!-- This is a work-around of PostSharp not preserving the public-signing flag. (#29763) -->
    <ItemGroup>
        <PackageReference Include="FakeSign" Version="0.9.2" PrivateAssets="all" GeneratePathProperty="true" />
    </ItemGroup>

    <PropertyGroup>
        <_FixPublicSigningTouchFile>$(MSBuildThisFileDirectory)\obj\$(Configuration)\$(TargetFramework)\fakesign_touch</_FixPublicSigningTouchFile>
    </PropertyGroup>

    <Target Name="FixPublicSigning" Inputs="@(IntermediateAssembly->'%(FullPath)')" Outputs="$(_FixPublicSigningTouchFile)" AfterTargets="PostSharp">
        <Exec Command="$(PkgFakeSign)\tools\FakeSign.exe $(MSBuildProjectDirectory)\obj\$(Configuration)\$(TargetFramework)\$(AssemblyName).dll" />
        <Touch Files="$(_FixPublicSigningTouchFile)" AlwaysCreate="True" ContinueOnError="True" />
    </Target>
    
    <!-- Include system types as managed resources -->
    <Import Sdk="PostSharp.Engineering.Sdk" Project="Assets.props" />

    <ItemGroup>
        <EmbeddedResource Include="$(AssetsDirectory)\system-types\*.cs" Link="(Resources)\%(Filename)" />
    </ItemGroup>

    <!-- Packaging -->
    <ItemGroup>
        <None Include="README.md" Pack="true" PackagePath="\" />
    </ItemGroup>

</Project>
