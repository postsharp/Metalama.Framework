// Copyright (c) SharpCrafters s.r.o. All rights reserved.
// This project is not open source. Please see the LICENSE.md file in the repository root for details.

using Metalama.Compiler;
using Metalama.Framework.Engine.AdditionalOutputs;
using Metalama.Framework.Engine.DesignTime.Pipeline;
using Metalama.Framework.Engine.DesignTime.Utilities;
using Metalama.Framework.Engine.Options;
using Metalama.Framework.Engine.Pipeline;
using Metalama.Framework.Engine.Utilities;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;

namespace Metalama.Framework.Engine.DesignTime
{
    /// <summary>
    /// Our implementation of <see cref="ISourceGenerator"/>. Provides the source code generated by the pipeline.
    /// </summary>
    [ExcludeFromCodeCoverage]
    public class DesignTimeSourceGenerator : ISourceGenerator
    {
        private bool _isEnabled;

        static DesignTimeSourceGenerator()
        {
            Logger.Initialize();
        }

        void ISourceGenerator.Execute( GeneratorExecutionContext context )
        {
            if ( !this._isEnabled || context.Compilation is not CSharpCompilation compilation )
            {
                return;
            }

            try
            {
                Logger.Instance?.Write(
                    $"DesignTimeSourceGenerator.Execute('{compilation.AssemblyName}', CompilationId = {DebuggingHelper.GetObjectId( compilation )})." );

                var projectOptions = new ProjectOptions( context.AnalyzerConfigOptions );

                DebuggingHelper.AttachDebugger( projectOptions );

                if ( !projectOptions.IsDesignTimeEnabled )
                {
                    // Execute the fallback.
                    Logger.Instance?.Write(
                        $"DesignTimeSourceGenerator.Execute('{compilation.AssemblyName}'): DesignTimeEnabled is false, will output fallback files from '{projectOptions.AdditionalCompilationOutputDirectory}'." );

                    ExecuteFromAdditionalCompilationOutputFiles( context, projectOptions );

                    return;
                }

                // Execute the pipeline.
                var cancellationToken = context.CancellationToken.IgnoreIfDebugging();

                if ( !DesignTimeAspectPipelineFactory.Instance.TryExecute(
                        projectOptions,
                        compilation,
                        cancellationToken,
                        out var compilationResult ) )
                {
                    Logger.Instance?.Write(
                        $"DesignTimeSourceGenerator.Execute('{compilation.AssemblyName}', CompilationId = {DebuggingHelper.GetObjectId( compilation )}): the pipeline failed." );

                    Logger.Instance?.Write(
                        " Compilation references: " + string.Join(
                            ", ",
                            compilation.References.GroupBy( r => r.GetType() ).Select( g => $"{g.Key.Name}: {g.Count()}" ) ) );

                    return;
                }

                // Add introduced syntax trees.
                var sourcesCount = 0;

                foreach ( var introducedSyntaxTree in compilationResult.PipelineResult.IntroducedSyntaxTrees )
                {
                    sourcesCount++;
                    Logger.Instance?.Write( $"  AddSource('{introducedSyntaxTree.Name}')" );
                    context.AddSource( introducedSyntaxTree.Name, introducedSyntaxTree.GeneratedSyntaxTree.GetText() );
                }

                Logger.Instance?.Write(
                    $"DesignTimeSourceGenerator.Execute('{compilation.AssemblyName}', CompilationId = {DebuggingHelper.GetObjectId( compilation )}): {sourcesCount} sources generated." );

                // We don't report diagnostics because it seems to be without effect.
                // All diagnostics are reported by the analyzer.
            }
            catch ( Exception e ) when ( DesignTimeExceptionHandler.MustHandle( e ) )
            {
                DesignTimeExceptionHandler.ReportException( e );
            }
        }

        private static void ExecuteFromAdditionalCompilationOutputFiles( GeneratorExecutionContext context, IProjectOptions projectOptions )
        {
            var serviceProvider = ServiceProvider.Empty.WithServices( projectOptions );
            var provider = new AdditionalCompilationOutputFileProvider( serviceProvider );

            if ( projectOptions.AdditionalCompilationOutputDirectory == null )
            {
                return;
            }

            var sourcesCount = 0;

            foreach ( var file in provider.GetAdditionalCompilationOutputFiles()
                         .Where(
                             f => f.Kind == AdditionalCompilationOutputFileKind.DesignTimeGeneratedCode
                                  && StringComparer.Ordinal.Equals( Path.GetExtension( f.Path ), ".cs" ) ) )
            {
                using var stream = file.GetStream();
                context.AddSource( Path.GetFileName( file.Path ), SourceText.From( stream ) );
                sourcesCount++;
            }

            Logger.Instance?.Write( $"DesignTimeSourceGenerator.Execute('{context.Compilation.AssemblyName}'): {sourcesCount} sources generated." );
        }

        void ISourceGenerator.Initialize( GeneratorInitializationContext context )
        {
            this._isEnabled = !MetalamaCompilerInfo.IsActive;
        }
    }
}